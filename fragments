	// var f func(*html.Node)
	// f = func(n *html.Node) {
	// 	if n.Type == html.ElementNode && n.Data == "p" {
	// 		if n.FirstChild != nil && n.FirstChild.Type == html.TextNode {
	// 			// if yes, retrieve FirstChild's data (name)
	// 			data := n.FirstChild.Data
	// 			// print name
	// 			fmt.Println(data)
	// 		}
	// 	}
	// 	for c := n.FirstChild; c != nil; c = c.NextSibling {
	// 		f(c)
	// 	}
	// }
	// f(doc)

	// depth := 0
	// for {
	// 	tt := z.Next()
	// 	switch tt {
	// 	case html.ErrorToken:
	// 		return z.Err()
	// 	case html.TextToken:
	// 		if depth > 0 {
	// 			// emitBytes should copy the []byte it receives,
	// 			// if it doesn't process it immediately.
	// 			emitBytes(z.Text())
	// 		}
	// 	case html.StartTagToken, html.EndTagToken:
	// 		tn, _ := z.TagName()
	// 		if len(tn) == 1 && tn[0] == 'a' {
	// 			if tt == html.StartTagToken {
	// 				depth++
	// 			} else {
	// 				depth--
	// 			}
	// 		}
	// 	}
	// }

	// case "span":
	// 	for _, a := range n.Attr {
	// 		if a.Key == "class" && a.Val == "bold" {
	// 			for c := n.FirstChild; c != nil; c = c.NextSibling {
	// 				if c.Type == html.TextNode {
	// 					fmt.Println("bold:", c.Data)
	// 				}
	// 			}
	// 		}
	// 	}


func AnnotateKGW(markdown string, books map[string][]string) string {
	// # [15 = W II 6a. Fr√ºhjahr 1888]
	book_rx, _ := regexp.Compile(`(?m)^# \[(.+)\]$`)
	// ## eKGWB/NF-1888,15[1]
	aphorism_rx, _ := regexp.Compile(`(?m)^## eKGWB/.*,(.*)$`)
	res := book_rx.FindStringSubmatch(markdown)
	if res == nil {
		panic("nope")
		return markdown
	}

	aphs, ok := books[res[1]]
	if !ok {
		panic("nope")
		return markdown
	}

	out := ""
	h2s := aphorism_rx.FindAllStringIndex(markdown, -1)
	for i, h2 := range h2s {
		fmt.Println(h2)
		header := markdown[h2[0]:h2[1]]
		_, header, ok := strings.Cut(header, ",")
		if !ok {
			panic("nope")
			return markdown
		}
		fmt.Println(header)
		if strings.Contains(aphs[i], header) {
			out += markdown[:h2[1]] + aphs[i] + markdown[h2[1]:]
		} else {
			panic("nope")
		}
	}

	return out
}


func GetYear(book string) string {
	r, _ := regexp.Compile(`.+ (18\d\d).*`)
	matches := r.FindStringSubmatch(book)
	if matches == nil || len(matches) < 2 {
		return book
	}
	return matches[1]
}
